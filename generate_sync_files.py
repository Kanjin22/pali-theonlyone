import sqlite3
import json
import os
import re

db_path = "dpd_data/dpd.db"
output_derived = "data/vocab-roots-dpd-derived.js"
# output_dpd = "data/vocab-dpd.js" # Generated by extract_dpd.py instead

if not os.path.exists(db_path):
    print(f"Database not found at {db_path}")
    exit(1)

conn = sqlite3.connect(db_path)
cursor = conn.cursor()

# Roman to Thai Transliteration Logic (Copied from extract_dpd_roots.py)
def roman_to_thai(text):
    if not text:
        return ""
    
    # 1. Pre-processing
    text = text.lower().strip()
    
    # Mapping
    consonants = {
        'k': 'ก', 'kh': 'ข', 'g': 'ค', 'gh': 'ฆ', 'ṅ': 'ง',
        'c': 'จ', 'ch': 'ฉ', 'j': 'ช', 'jh': 'ฌ', 'ñ': 'ญ',
        'ṭ': 'ฏ', 'ṭh': 'ฐ', 'ḍ': 'ฑ', 'ḍh': 'ฒ', 'ṇ': 'ณ',
        't': 'ต', 'th': 'ถ', 'd': 'ท', 'dh': 'ธ', 'n': 'น',
        'p': 'ป', 'ph': 'ผ', 'b': 'พ', 'bh': 'ภ', 'm': 'ม',
        'y': 'ย', 'r': 'ร', 'l': 'ล', 'v': 'ว', 's': 'ส', 'h': 'ห', 'ḷ': 'ฬ',
        'ṃ': 'ํ'
    }
    
    vowels = {
        'a': '', # Implicit
        'ā': 'า',
        'i': 'ิ',
        'ī': 'ี',
        'u': 'ุ',
        'ū': 'ู',
        'e': 'เ',
        'o': 'โ'
    }
    
    res = ""
    i = 0
    length = len(text)
    
    while i < length:
        char = text[i]
        next_char = text[i+1] if i + 1 < length else ""
        
        cons = ""
        cons_len = 0
        
        if char + next_char in consonants:
            cons = consonants[char + next_char]
            cons_len = 2
        elif char in consonants:
            cons = consonants[char]
            cons_len = 1
            
        if cons:
            i += cons_len
            vowel_char = text[i] if i < length else ""
            
            if vowel_char in vowels:
                v_thai = vowels[vowel_char]
                if vowel_char in ['e', 'o']:
                    res += v_thai + cons
                else:
                    res += cons + v_thai
                i += 1
                
                next_v = text[i] if i < length else ""
                if next_v == 'ṃ':
                    res += 'ํ'
                    i += 1
            elif vowel_char == 'ṃ':
                 res += cons + 'ํ'
                 i += 1
            else:
                res += cons + 'ฺ'
        else:
            if char in vowels:
                initial_vowels = {
                    'a': 'อ', 'ā': 'อา', 'i': 'อิ', 'ī': 'อี',
                    'u': 'อุ', 'ū': 'อู', 'e': 'เอ', 'o': 'โอ'
                }
                if char in initial_vowels:
                    res += initial_vowels[char]
                    i += 1
                    next_v = text[i] if i < length else ""
                    if next_v == 'ṃ':
                        res += 'ํ'
                        i += 1
                else:
                    if char != '√' and char != ' ':
                         res += char
                    i += 1
            else:
                if char not in ['√']:
                    res += char
                i += 1
                
    return res

def generate_derived():
    print("Generating vocab-roots-dpd-derived.js...")
    cursor.execute("SELECT root_key, lemma_1 FROM dpd_headwords WHERE root_key IS NOT NULL AND root_key != ''")
    rows = cursor.fetchall()
    
    derived_map = {}
    for root_key, lemma in rows:
        # Convert root_key to Thai
        root_clean = root_key.replace("√", "").strip()
        # Remove trailing numbers (homonym index) to match root list keys
        root_clean = re.sub(r'\s+\d+$', '', root_clean)
        
        root_thai = roman_to_thai(root_clean)
        
        if root_thai not in derived_map:
            derived_map[root_thai] = []
        if lemma not in derived_map[root_thai]:
            derived_map[root_thai].append(lemma)
            
    # Sort keys
    sorted_keys = sorted(derived_map.keys())
    sorted_map = {k: sorted(derived_map[k]) for k in sorted_keys}
    
    with open(output_derived, "w", encoding="utf-8") as f:
        f.write("const vocabRootsDPDDerived = ")
        json.dump(sorted_map, f, ensure_ascii=False, indent=2)
        f.write(";")
    print(f"Saved {len(sorted_map)} roots to {output_derived}")

# def generate_dpd_definitions():
#     print("Generating vocab-dpd.js...")
#     # ... (Logic moved/handled by extract_dpd.py)
#     pass

if __name__ == "__main__":
    generate_derived()
    # generate_dpd_definitions()
    conn.close()
