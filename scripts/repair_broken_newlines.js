const fs = require('fs');
const path = require('path');

const FILE_PATH = path.join(__dirname, '../data/content-dhamma02.js');

function repairNewlines() {
    console.log(`Reading ${FILE_PATH}...`);
    const content = fs.readFileSync(FILE_PATH, 'utf8');
    const lines = content.split('\n');
    const newLines = [];
    
    let buffer = "";
    let inString = false;
    
    // Regex to detect start of a property definition: whitespace + key + : + whitespace + "
    // e.g. '                pali: "text...'
    const startPropRegex = /^(\s+\w+:\s*)"(.*)$/;
    
    // Regex to detect end of a string value: ends with " or ", (ignoring whitespace)
    // Note: escaped quotes \" don't count as end.
    const endStringRegex = /(?<!\\)"(,?)$/;

    for (let i = 0; i < lines.length; i++) {
        let line = lines[i];
        // Remove \r if present
        if (line.endsWith('\r')) line = line.slice(0, -1);
        
        if (inString) {
            // We are inside a broken string.
            // Check if this line ends the string.
            if (endStringRegex.test(line)) {
                // Found the end.
                // Escape any quotes in the middle? No, assuming they are fine.
                // Trim leading whitespace of continuation lines? 
                // Usually multiline strings in code might have indentation.
                // But here it was generated by `fix_samavati_merge_all_splits.js` which puts literal newlines.
                // The literal newline was preserved from the value.
                // The value likely had NO indentation for the new line?
                // Or maybe it did?
                // Let's assume we just join them.
                buffer += "\\n" + line.trim(); // Use \n text. And trim? 
                // Wait, if I trim, I lose spaces at start of line.
                // But the file indentation is there.
                // If the broken line looks like:
                // "text"
                // "  continuation"
                // My formatter output `s += ...`.
                // If `strVal` had `\n`, it became a newline char.
                // The next line in file starts at column 0?
                // Let's look at the read output.
                /*
                13184→                pali: "โส ... อิมํ คาถมาห 
                13185→“สมฺมุยฺหามิ ...
                */
                // Line 13185 starts with `“`. It does NOT have indentation?
                // Wait, the arrow `→` is from `cat -n` style?
                // `Read` tool output:
                // `13185→“สมฺมุยฺหามิ ...`
                // It seems there is NO indentation on the continuation line.
                // So I can just append it.
                
                // But I should put `\n` to represent the newline.
                
                newLines.push(buffer + "\\n" + line); // Check if we need to trim line?
                // If line 13185 has no spaces at start, then `line` is just the text.
                // So `buffer + "\\n" + line` is correct.
                
                buffer = "";
                inString = false;
            } else {
                // Still in string
                buffer += "\\n" + line;
            }
        } else {
            // Not in string. Check if this line STARTS a string but doesn't END it.
            const match = line.match(startPropRegex);
            if (match) {
                // It starts a property.
                // Check if it ends correctly.
                // Note: match[2] is the content after "
                // We check if the whole line ends with " or ",
                if (endStringRegex.test(line)) {
                    // It's a single line string. Good.
                    newLines.push(line);
                } else {
                    // It's broken.
                    inString = true;
                    buffer = line; // Start buffering
                }
            } else {
                // Normal line (brace, etc.)
                newLines.push(line);
            }
        }
    }
    
    if (buffer) {
        console.error("Error: EOF reached while inside a string!");
        newLines.push(buffer); // Push anyway
    }

    fs.writeFileSync(FILE_PATH, newLines.join('\n'), 'utf8');
    console.log("File repaired (newlines escaped).");
}

repairNewlines();
